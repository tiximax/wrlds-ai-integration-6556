import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  OrderService,
  Order,
  OrderItem,
  OrderStatus,
  ShippingAddress,
  OrderFilter,
  OrderSummary,
  Receipt,
  EmailNotification
} from '../orderService';

describe('OrderService', () => {
  let orderService: OrderService;

  beforeEach(() => {
    orderService = new OrderService();
    vi.clearAllTimers();
  });

  const mockShippingAddress: ShippingAddress = {
    firstName: 'John',
    lastName: 'Doe',
    company: 'Acme Corp',
    address: '123 Main St',
    apartment: 'Apt 4B',
    city: 'New York',
    state: 'NY',
    zipCode: '10001',
    country: 'US',
    phone: '+1-555-0123',
    isDefault: true
  };

  const mockOrderItems: OrderItem[] = [
    {
      id: 'item_1',
      productId: 'prod_1',
      name: 'Test Product 1',
      description: 'A great test product',
      image: '/test-image-1.jpg',
      quantity: 2,
      price: 49.99,
      originalPrice: 59.99,
      sku: 'TEST-001',
      variant: {
        size: 'M',
        color: 'Blue'
      },
      category: {
        id: 'cat_1',
        name: 'Electronics'
      },
      brand: {
        id: 'brand_1',
        name: 'TestBrand'
      }
    },
    {
      id: 'item_2',
      productId: 'prod_2',
      name: 'Test Product 2',
      quantity: 1,
      price: 99.99,
      sku: 'TEST-002'
    }
  ];

  describe('Order Creation', () => {
    it('should create an order successfully', async () => {
      const orderData = {
        customerId: 'customer_123',
        customerEmail: 'customer@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123',
        promoCode: {
          code: 'SAVE10',
          discountAmount: 15.00,
          discountType: 'fixed' as const
        }
      };

      const order = await orderService.createOrder(orderData);

      expect(order).toBeDefined();
      expect(order.id).toContain('order_');
      expect(order.orderNumber).toContain('ORD-');
      expect(order.customerId).toBe(orderData.customerId);
      expect(order.customerEmail).toBe(orderData.customerEmail);
      expect(order.items).toHaveLength(2);
      expect(order.status).toBe('pending');
      expect(order.subtotal).toBe(199.97); // (49.99 * 2) + 99.99
      expect(order.discount).toBe(15.00);
      expect(order.total).toBeGreaterThan(0);
      expect(order.createdAt).toBeInstanceOf(Date);
    });

    it('should create order without promo code', async () => {
      const orderData = {
        customerId: 'customer_123',
        customerEmail: 'customer@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      };

      const order = await orderService.createOrder(orderData);

      expect(order.discount).toBe(0);
      expect(order.promoCode).toBeUndefined();
    });

    it('should handle empty items list', async () => {
      const orderData = {
        customerId: 'customer_123',
        customerEmail: 'customer@example.com',
        items: [],
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      };

      await expect(orderService.createOrder(orderData))
        .rejects.toThrow('Cannot create order with empty items');
    });

    it('should calculate taxes and shipping correctly', async () => {
      const orderData = {
        customerId: 'customer_123',
        customerEmail: 'customer@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      };

      const order = await orderService.createOrder(orderData);

      expect(order.tax).toBeGreaterThan(0);
      expect(order.shipping).toBeGreaterThan(0);
      expect(order.total).toBe(order.subtotal + order.tax + order.shipping - order.discount);
    });
  });

  describe('Order Retrieval', () => {
    it('should get order by ID', async () => {
      const orderData = {
        customerId: 'customer_123',
        customerEmail: 'customer@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      };

      const createdOrder = await orderService.createOrder(orderData);
      const retrievedOrder = await orderService.getOrder(createdOrder.id);

      expect(retrievedOrder).toBeDefined();
      expect(retrievedOrder?.id).toBe(createdOrder.id);
      expect(retrievedOrder?.orderNumber).toBe(createdOrder.orderNumber);
    });

    it('should return null for non-existent order', async () => {
      const order = await orderService.getOrder('non_existent_order');
      expect(order).toBeNull();
    });

    it('should get orders by customer ID', async () => {
      const customerId = 'customer_123';
      
      // Create multiple orders
      await orderService.createOrder({
        customerId,
        customerEmail: 'customer@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      });

      await orderService.createOrder({
        customerId,
        customerEmail: 'customer@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_456'
      });

      const customerOrders = await orderService.getOrdersByCustomer(customerId);

      expect(customerOrders).toHaveLength(2);
      expect(customerOrders.every(order => order.customerId === customerId)).toBe(true);
    });
  });

  describe('Order Status Management', () => {
    let testOrder: Order;

    beforeEach(async () => {
      testOrder = await orderService.createOrder({
        customerId: 'customer_123',
        customerEmail: 'customer@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      });
    });

    it('should update order status successfully', async () => {
      const updatedOrder = await orderService.updateOrderStatus(testOrder.id, 'confirmed');

      expect(updatedOrder.status).toBe('confirmed');
      expect(updatedOrder.confirmedAt).toBeInstanceOf(Date);
      expect(updatedOrder.updatedAt).toBeInstanceOf(Date);
    });

    it('should handle invalid status transitions', async () => {
      // First confirm the order
      await orderService.updateOrderStatus(testOrder.id, 'delivered');
      
      // Try to go back to pending (invalid transition)
      await expect(orderService.updateOrderStatus(testOrder.id, 'pending'))
        .rejects.toThrow('Invalid status transition');
    });

    it('should update shipping status', async () => {
      const trackingNumber = 'TRACK123456';
      const carrier = 'UPS';

      const updatedOrder = await orderService.updateShippingStatus(
        testOrder.id,
        'shipped',
        {
          trackingNumber,
          carrier,
          message: 'Package shipped via UPS'
        }
      );

      expect(updatedOrder.shippingDetails.status).toBe('shipped');
      expect(updatedOrder.shippingDetails.trackingNumber).toBe(trackingNumber);
      expect(updatedOrder.shippingDetails.carrier).toBe(carrier);
      expect(updatedOrder.shippingDetails.updates).toHaveLength(1);
    });

    it('should cancel order successfully', async () => {
      const reason = 'Customer requested cancellation';
      const cancelledOrder = await orderService.cancelOrder(testOrder.id, reason);

      expect(cancelledOrder.status).toBe('cancelled');
      expect(cancelledOrder.cancellationReason).toBe(reason);
      expect(cancelledOrder.cancelledAt).toBeInstanceOf(Date);
    });

    it('should not cancel delivered order', async () => {
      await orderService.updateOrderStatus(testOrder.id, 'delivered');

      await expect(orderService.cancelOrder(testOrder.id, 'Change of mind'))
        .rejects.toThrow('Cannot cancel order in current status');
    });
  });

  describe('Order Search and Filtering', () => {
    beforeEach(async () => {
      // Create test orders with different statuses and dates
      await orderService.createOrder({
        customerId: 'customer_1',
        customerEmail: 'customer1@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      });

      const order2 = await orderService.createOrder({
        customerId: 'customer_2',
        customerEmail: 'customer2@example.com',
        items: [mockOrderItems[0]], // Single item
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_456'
      });

      await orderService.updateOrderStatus(order2.id, 'confirmed');
    });

    it('should search orders with filters', async () => {
      const filter: OrderFilter = {
        status: ['pending'],
        minAmount: 50,
        maxAmount: 500
      };

      const results = await orderService.searchOrders(filter);

      expect(results.orders.length).toBeGreaterThan(0);
      expect(results.orders.every(order => order.status === 'pending')).toBe(true);
      expect(results.orders.every(order => order.total >= 50 && order.total <= 500)).toBe(true);
    });

    it('should search orders by customer ID', async () => {
      const filter: OrderFilter = {
        customerId: 'customer_1'
      };

      const results = await orderService.searchOrders(filter);

      expect(results.orders.every(order => order.customerId === 'customer_1')).toBe(true);
    });

    it('should search orders by date range', async () => {
      const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);
      const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000);

      const filter: OrderFilter = {
        dateFrom: yesterday,
        dateTo: tomorrow
      };

      const results = await orderService.searchOrders(filter);

      expect(results.orders.length).toBeGreaterThan(0);
      expect(results.orders.every(order => 
        order.createdAt >= yesterday && order.createdAt <= tomorrow
      )).toBe(true);
    });

    it('should search orders with pagination', async () => {
      const results = await orderService.searchOrders({}, { page: 1, limit: 1 });

      expect(results.orders).toHaveLength(1);
      expect(results.pagination.page).toBe(1);
      expect(results.pagination.limit).toBe(1);
      expect(results.pagination.total).toBeGreaterThanOrEqual(1);
    });
  });

  describe('Order Analytics', () => {
    beforeEach(async () => {
      // Create test orders for analytics
      const order1 = await orderService.createOrder({
        customerId: 'customer_1',
        customerEmail: 'customer1@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      });

      await orderService.updateOrderStatus(order1.id, 'completed');

      const order2 = await orderService.createOrder({
        customerId: 'customer_2', 
        customerEmail: 'customer2@example.com',
        items: [mockOrderItems[0]],
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_456'
      });

      await orderService.updateOrderStatus(order2.id, 'cancelled');
    });

    it('should generate order summary', async () => {
      const summary = await orderService.getOrderSummary();

      expect(summary).toBeDefined();
      expect(summary.totalOrders).toBeGreaterThan(0);
      expect(summary.totalRevenue).toBeGreaterThanOrEqual(0);
      expect(summary.averageOrderValue).toBeGreaterThanOrEqual(0);
      expect(summary.completedOrders).toBeGreaterThanOrEqual(0);
      expect(summary.cancelledOrders).toBeGreaterThanOrEqual(0);
      expect(summary.statusBreakdown).toBeDefined();
      expect(summary.topProducts).toBeInstanceOf(Array);
      expect(summary.revenueByMonth).toBeInstanceOf(Array);
    });

    it('should generate summary for date range', async () => {
      const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);
      const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000);

      const summary = await orderService.getOrderSummary(yesterday, tomorrow);

      expect(summary.totalOrders).toBeGreaterThan(0);
    });
  });

  describe('Receipt Generation', () => {
    let testOrder: Order;

    beforeEach(async () => {
      testOrder = await orderService.createOrder({
        customerId: 'customer_123',
        customerEmail: 'customer@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      });
    });

    it('should generate receipt for completed order', async () => {
      await orderService.updateOrderStatus(testOrder.id, 'completed');

      const receipt = await orderService.generateReceipt(testOrder.id);

      expect(receipt).toBeDefined();
      expect(receipt.orderId).toBe(testOrder.id);
      expect(receipt.orderNumber).toBe(testOrder.orderNumber);
      expect(receipt.customer.email).toBe(testOrder.customerEmail);
      expect(receipt.items).toHaveLength(testOrder.items.length);
      expect(receipt.total).toBe(testOrder.total);
      expect(receipt.issuedAt).toBeInstanceOf(Date);
      expect(receipt.businessInfo).toBeDefined();
    });

    it('should not generate receipt for pending order', async () => {
      await expect(orderService.generateReceipt(testOrder.id))
        .rejects.toThrow('Cannot generate receipt for order in current status');
    });
  });

  describe('Email Notifications', () => {
    let testOrder: Order;

    beforeEach(async () => {
      testOrder = await orderService.createOrder({
        customerId: 'customer_123',
        customerEmail: 'customer@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      });
    });

    it('should send order confirmation email', async () => {
      const result = await orderService.sendOrderConfirmationEmail(testOrder.id);

      expect(result.success).toBe(true);
      expect(result.emailId).toBeDefined();
    });

    it('should send shipping notification email', async () => {
      await orderService.updateOrderStatus(testOrder.id, 'shipped');

      const result = await orderService.sendShippingNotificationEmail(testOrder.id);

      expect(result.success).toBe(true);
    });

    it('should get notification history', async () => {
      await orderService.sendOrderConfirmationEmail(testOrder.id);
      await orderService.updateOrderStatus(testOrder.id, 'shipped');
      await orderService.sendShippingNotificationEmail(testOrder.id);

      const notifications = await orderService.getNotificationHistory(testOrder.id);

      expect(notifications).toHaveLength(2);
      expect(notifications.some(n => n.type === 'order_confirmation')).toBe(true);
      expect(notifications.some(n => n.type === 'order_shipped')).toBe(true);
    });
  });

  describe('Order Updates', () => {
    let testOrder: Order;

    beforeEach(async () => {
      testOrder = await orderService.createOrder({
        customerId: 'customer_123',
        customerEmail: 'customer@example.com',
        items: mockOrderItems,
        shippingAddress: mockShippingAddress,
        paymentMethodId: 'pm_123'
      });
    });

    it('should update shipping address', async () => {
      const newAddress: ShippingAddress = {
        ...mockShippingAddress,
        address: '456 Oak St',
        city: 'Los Angeles',
        state: 'CA',
        zipCode: '90210'
      };

      const updatedOrder = await orderService.updateShippingAddress(testOrder.id, newAddress);

      expect(updatedOrder.shippingDetails.address.address).toBe('456 Oak St');
      expect(updatedOrder.shippingDetails.address.city).toBe('Los Angeles');
      expect(updatedOrder.updatedAt).toBeInstanceOf(Date);
    });

    it('should not update address for shipped order', async () => {
      await orderService.updateOrderStatus(testOrder.id, 'shipped');

      await expect(orderService.updateShippingAddress(testOrder.id, mockShippingAddress))
        .rejects.toThrow('Cannot update shipping address for order in current status');
    });

    it('should add order notes', async () => {
      const notes = 'Customer requested expedited shipping';
      const updatedOrder = await orderService.addOrderNotes(testOrder.id, notes);

      expect(updatedOrder.notes).toBe(notes);
      expect(updatedOrder.updatedAt).toBeInstanceOf(Date);
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid order data', async () => {
      await expect(orderService.createOrder({
        customerId: '',
        customerEmail: 'invalid-email',
        items: [],
        shippingAddress: mockShippingAddress,
        paymentMethodId: ''
      })).rejects.toThrow();
    });

    it('should handle order not found', async () => {
      await expect(orderService.updateOrderStatus('non_existent', 'confirmed'))
        .rejects.toThrow('Order not found');
    });

    it('should handle invalid email notifications', async () => {
      const result = await orderService.sendOrderConfirmationEmail('non_existent');
      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });
});

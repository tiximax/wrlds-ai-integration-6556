/**\n * Error Recovery Utilities\n * Provides reusable patterns for error handling, retries, and graceful degradation\n */\n\nimport { logger } from './logger';\n\n/**\n * Retry configuration\n */\nexport interface RetryOptions {\n  maxAttempts: number;\n  initialDelayMs: number;\n  maxDelayMs: number;\n  backoffMultiplier: number;\n  timeoutMs?: number;\n}\n\n/**\n * Default retry configuration\n */\nexport const DEFAULT_RETRY_OPTIONS: RetryOptions = {\n  maxAttempts: 3,\n  initialDelayMs: 500,\n  maxDelayMs: 5000,\n  backoffMultiplier: 2,\n  timeoutMs: 10000\n};\n\n/**\n * Calculate exponential backoff delay with jitter\n */\nfunction calculateBackoffDelay(attempt: number, options: RetryOptions): number {\n  const exponentialDelay = Math.min(\n    options.initialDelayMs * Math.pow(options.backoffMultiplier, attempt),\n    options.maxDelayMs\n  );\n  // Add jitter (Â±20%) to prevent thundering herd\n  const jitter = exponentialDelay * 0.2 * (Math.random() - 0.5);\n  return Math.max(100, exponentialDelay + jitter);\n}\n\n/**\n * Delay helper for wait periods\n */\nexport function delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generic retry function with exponential backoff\n * Useful for any async operation that might fail temporarily\n */\nexport async function retryWithBackoff<T>(\n  operation: () => Promise<T>,\n  operationName: string,\n  options: Partial<RetryOptions> = {}\n): Promise<T> {\n  const config = { ...DEFAULT_RETRY_OPTIONS, ...options };\n  let lastError: Error | null = null;\n\n  for (let attempt = 0; attempt < config.maxAttempts; attempt++) {\n    try {\n      logger.debug(`Attempting ${operationName}`, { attempt: attempt + 1, maxAttempts: config.maxAttempts });\n      return await operation();\n    } catch (error) {\n      lastError = error as Error;\n      const isLastAttempt = attempt === config.maxAttempts - 1;\n\n      if (isLastAttempt) {\n        logger.error(`${operationName} failed after ${config.maxAttempts} attempts`, {\n          error: String(error)\n        });\n        throw error;\n      }\n\n      const delayMs = calculateBackoffDelay(attempt, config);\n      logger.warn(`${operationName} attempt ${attempt + 1} failed, retrying in ${Math.round(delayMs)}ms`, {\n        error: String(error),\n        attempt: attempt + 1,\n        nextRetryDelayMs: Math.round(delayMs)\n      });\n\n      await delay(delayMs);\n    }\n  }\n\n  throw lastError || new Error(`${operationName} failed`);\n}\n\n/**\n * Circuit Breaker Pattern\n * Prevents cascading failures by stopping requests to failing services\n */\nexport class CircuitBreaker<T> {\n  private failureCount = 0;\n  private successCount = 0;\n  private lastFailureTime: number | null = null;\n  private state: 'closed' | 'open' | 'half-open' = 'closed';\n\n  constructor(\n    private operation: () => Promise<T>,\n    private operationName: string,\n    private config = {\n      failureThreshold: 5, // Open after N failures\n      successThreshold: 2, // Close after N successes in half-open\n      timeoutMs: 60000 // Try again after N ms\n    }\n  ) {}\n\n  async execute(): Promise<T> {\n    if (this.state === 'open') {\n      // Check if we should transition to half-open\n      if (this.lastFailureTime && Date.now() - this.lastFailureTime > this.config.timeoutMs) {\n        logger.info(`Circuit breaker for ${this.operationName} transitioning to half-open`);\n        this.state = 'half-open';\n        this.successCount = 0;\n      } else {\n        logger.warn(`Circuit breaker for ${this.operationName} is OPEN - request blocked`);\n        throw new Error(`Circuit breaker open for ${this.operationName}`);\n      }\n    }\n\n    try {\n      const result = await this.operation();\n\n      // Success - update counts\n      this.failureCount = 0;\n      if (this.state === 'half-open') {\n        this.successCount++;\n        if (this.successCount >= this.config.successThreshold) {\n          logger.info(`Circuit breaker for ${this.operationName} closing`);\n          this.state = 'closed';\n        }\n      }\n\n      return result;\n    } catch (error) {\n      // Failure - update counts\n      this.failureCount++;\n      this.lastFailureTime = Date.now();\n\n      if (this.state === 'half-open') {\n        // Transition back to open if failure in half-open state\n        logger.warn(`Circuit breaker for ${this.operationName} reopening after failure in half-open`);\n        this.state = 'open';\n      } else if (this.failureCount >= this.config.failureThreshold) {\n        logger.error(`Circuit breaker for ${this.operationName} opening after ${this.failureCount} failures`);\n        this.state = 'open';\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Reset circuit breaker state\n   */\n  reset(): void {\n    logger.debug(`Resetting circuit breaker for ${this.operationName}`);\n    this.state = 'closed';\n    this.failureCount = 0;\n    this.successCount = 0;\n    this.lastFailureTime = null;\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): string {\n    return this.state;\n  }\n}\n\n/**\n * Fallback function wrapper\n * Provides a fallback value if the main operation fails\n */\nexport async function withFallback<T>(\n  operation: () => Promise<T>,\n  fallbackValue: T,\n  operationName: string\n): Promise<T> {\n  try {\n    logger.debug(`Executing ${operationName} with fallback`);\n    return await operation();\n  } catch (error) {\n    logger.warn(`${operationName} failed, using fallback value`, {\n      error: String(error)\n    });\n    return fallbackValue;\n  }\n}\n\n/**\n * Timeout wrapper for async operations\n */\nexport async function withTimeout<T>(\n  operation: () => Promise<T>,\n  timeoutMs: number,\n  operationName: string\n): Promise<T> {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    logger.debug(`Executing ${operationName} with ${timeoutMs}ms timeout`);\n    return await Promise.race([\n      operation(),\n      new Promise<T>((_, reject) => {\n        const checkTimeout = setInterval(() => {\n          if (controller.signal.aborted) {\n            clearInterval(checkTimeout);\n            reject(new Error(`${operationName} timed out after ${timeoutMs}ms`));\n          }\n        }, 100);\n      })\n    ]);\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n/**\n * Combination: Retry with circuit breaker\n */\nexport async function executeWithRecovery<T>(\n  operation: () => Promise<T>,\n  operationName: string,\n  circuitBreaker?: CircuitBreaker<T>,\n  retryOptions?: Partial<RetryOptions>\n): Promise<T> {\n  if (circuitBreaker) {\n    // Execute through circuit breaker with retries\n    return retryWithBackoff(\n      () => circuitBreaker.execute(),\n      operationName,\n      retryOptions\n    );\n  } else {\n    // Just use retries\n    return retryWithBackoff(operation, operationName, retryOptions);\n  }\n}\n\n/**\n * Error classification for better error handling\n */\nexport type ErrorCategory = 'network' | 'timeout' | 'validation' | 'authorization' | 'rate_limit' | 'server' | 'unknown';\n\nexport function classifyError(error: any): ErrorCategory {\n  if (error instanceof TypeError && error.message.includes('timeout')) {\n    return 'timeout';\n  }\n\n  if (error instanceof TypeError && error.message.includes('Failed to fetch')) {\n    return 'network';\n  }\n\n  if (error.status === 400 || error.status === 422) {\n    return 'validation';\n  }\n\n  if (error.status === 401 || error.status === 403) {\n    return 'authorization';\n  }\n\n  if (error.status === 429) {\n    return 'rate_limit';\n  }\n\n  if (error.status >= 500) {\n    return 'server';\n  }\n\n  return 'unknown';\n}\n\n/**\n * User-friendly error messages\n */\nexport function getUserFriendlyErrorMessage(category: ErrorCategory, operationName: string): string {\n  const messages: Record<ErrorCategory, string> = {\n    timeout: `${operationName} took too long. Please try again.`,\n    network: `Connection error. Please check your internet and try again.`,\n    validation: `Invalid information provided. Please check and try again.`,\n    authorization: `You don't have permission to perform this action.`,\n    rate_limit: `Too many requests. Please wait a moment and try again.`,\n    server: `Service temporarily unavailable. Please try again later.`,\n    unknown: `Something went wrong. Please try again.`\n  };\n\n  return messages[category];\n}\n\nexport default {\n  retryWithBackoff,\n  CircuitBreaker,\n  withFallback,\n  withTimeout,\n  executeWithRecovery,\n  classifyError,\n  getUserFriendlyErrorMessage,\n  delay,\n  DEFAULT_RETRY_OPTIONS\n};\n"
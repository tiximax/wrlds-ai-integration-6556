/**\n * Keyboard Navigation Tests\n * Ensures all functionality is accessible via keyboard only\n */\n\nimport { test, expect } from '@playwright/test';\nimport { logger } from '@/utils/logger';\n\ntest.describe('Keyboard Navigation Accessibility', () => {\n  /**\n   * Tab Navigation Through Page\n   * Ensures Tab key moves focus through interactive elements in logical order\n   */\n  test('Tab key navigates through all interactive elements', async ({ page }) => {\n    logger.info('Testing Tab navigation');\n    \n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Start with no focus\n    await page.evaluate(() => (document.activeElement as HTMLElement).blur());\n    \n    const focusedElements: string[] = [];\n    let focusedCount = 0;\n    const maxTabs = 20; // Limit to avoid infinite loop\n    \n    // Track focus movement\n    for (let i = 0; i < maxTabs; i++) {\n      // Get current focused element\n      const currentFocused = await page.evaluate(() => {\n        const el = document.activeElement as HTMLElement;\n        if (!el || el === document.body) return null;\n        return `${el.tagName.toLowerCase()}.${el.className?.split(' ')[0] || 'no-class'}`;\n      });\n      \n      if (currentFocused) {\n        focusedElements.push(currentFocused);\n        focusedCount++;\n        logger.debug(`Tab ${i + 1}: Focused on ${currentFocused}`);\n      }\n      \n      // Press Tab\n      await page.keyboard.press('Tab');\n      \n      // Check if focus moved\n      const newFocused = await page.evaluate(() => {\n        const el = document.activeElement as HTMLElement;\n        return el && el !== document.body ? el.tagName : null;\n      });\n      \n      if (!newFocused) {\n        logger.info('Tab navigation ended (reached end of focusable elements)');\n        break;\n      }\n    }\n    \n    logger.info('Tab navigation test completed', {\n      focusedCount,\n      elements: focusedElements\n    });\n    \n    expect(focusedCount).toBeGreaterThan(0);\n  });\n\n  /**\n   * Shift+Tab Reverse Navigation\n   * Ensures Shift+Tab moves focus backwards through elements\n   */\n  test('Shift+Tab navigates backwards through interactive elements', async ({ page }) => {\n    logger.info('Testing Shift+Tab reverse navigation');\n    \n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Tab forward to some element\n    await page.keyboard.press('Tab');\n    await page.keyboard.press('Tab');\n    \n    const focusedBefore = await page.evaluate(() => {\n      return (document.activeElement as HTMLElement)?.tagName;\n    });\n    \n    logger.debug('Focused element before Shift+Tab', { element: focusedBefore });\n    \n    // Now go backwards\n    await page.keyboard.press('Shift+Tab');\n    \n    const focusedAfter = await page.evaluate(() => {\n      return (document.activeElement as HTMLElement)?.tagName;\n    });\n    \n    logger.debug('Focused element after Shift+Tab', { element: focusedAfter });\n    \n    expect(focusedAfter).not.toBe(focusedBefore);\n    logger.info('Shift+Tab navigation test completed');\n  });\n\n  /**\n   * Enter/Space on Buttons\n   * Ensures buttons can be activated with Enter and Space keys\n   */\n  test('Enter and Space keys activate buttons', async ({ page }) => {\n    logger.info('Testing Enter/Space on buttons');\n    \n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Find first button\n    const button = page.locator('button').first();\n    \n    if (await button.isVisible({ timeout: 2000 }).catch(() => false)) {\n      // Focus on button\n      await button.focus();\n      \n      const buttonText = await button.textContent();\n      logger.debug('Found button', { text: buttonText });\n      \n      // Test with Enter key\n      let clicked = false;\n      page.on('popup', () => {\n        clicked = true;\n      });\n      \n      // Listen for click event\n      const clickPromise = button.evaluate(el => {\n        return new Promise(resolve => {\n          el.addEventListener('click', () => resolve(true));\n          // Wait up to 500ms for click\n          setTimeout(() => resolve(false), 500);\n        });\n      });\n      \n      await page.keyboard.press('Enter');\n      const enterWorked = await clickPromise;\n      \n      logger.debug('Enter key activation', { worked: enterWorked });\n      expect(enterWorked).toBe(true);\n      \n      logger.info('Enter key activation test passed');\n    } else {\n      logger.warn('No buttons found on page');\n    }\n  });\n\n  /**\n   * Escape Key Closes Modals/Dropdowns\n   * Ensures Escape key closes modal dialogs and dropdowns\n   */\n  test('Escape key closes modals and dropdowns', async ({ page }) => {\n    logger.info('Testing Escape key for modals');\n    \n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Look for modal trigger\n    const modalTrigger = page.locator('button, [role=\"button\"]').filter({\n      hasText: /menu|options|settings|open/i\n    }).first();\n    \n    if (await modalTrigger.isVisible({ timeout: 2000 }).catch(() => false)) {\n      await modalTrigger.click();\n      await page.waitForTimeout(300);\n      \n      // Check if modal/dropdown appeared\n      const menu = page.locator('[role=\"menu\"], [role=\"dialog\"], .dropdown, .modal').first();\n      const isOpenBefore = await menu.isVisible({ timeout: 1000 }).catch(() => false);\n      \n      if (isOpenBefore) {\n        logger.debug('Modal/dropdown is open');\n        \n        // Press Escape\n        await page.keyboard.press('Escape');\n        await page.waitForTimeout(300);\n        \n        // Check if it closed\n        const isOpenAfter = await menu.isVisible({ timeout: 1000 }).catch(() => false);\n        logger.debug('Modal/dropdown after Escape', { isOpen: isOpenAfter });\n        \n        // Modal should be closed\n        expect(!isOpenAfter).toBe(true);\n        logger.info('Escape key test passed');\n      } else {\n        logger.warn('Modal/dropdown did not open');\n      }\n    } else {\n      logger.warn('No modal/menu trigger found');\n    }\n  });\n\n  /**\n   * Arrow Keys in Menus\n   * Ensures arrow keys navigate menu items (Up/Down for vertical, Left/Right for horizontal)\n   */\n  test('Arrow keys navigate menu items', async ({ page }) => {\n    logger.info('Testing arrow key navigation in menus');\n    \n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Look for menu\n    const menu = page.locator('nav, [role=\"menubar\"]').first();\n    \n    if (await menu.isVisible({ timeout: 2000 }).catch(() => false)) {\n      const menuItems = await menu.locator('[role=\"menuitem\"], li > a, li > button').count();\n      logger.debug('Menu items found', { count: menuItems });\n      \n      if (menuItems > 0) {\n        // Focus first item\n        const firstItem = menu.locator('[role=\"menuitem\"], li > a, li > button').first();\n        await firstItem.focus();\n        \n        const firstFocused = await page.evaluate(() => {\n          return (document.activeElement as HTMLElement)?.textContent?.trim();\n        });\n        \n        logger.debug('First menu item focused', { text: firstFocused });\n        \n        // Try arrow down\n        await page.keyboard.press('ArrowDown');\n        await page.waitForTimeout(100);\n        \n        const secondFocused = await page.evaluate(() => {\n          return (document.activeElement as HTMLElement)?.textContent?.trim();\n        });\n        \n        logger.debug('After ArrowDown', { text: secondFocused });\n        logger.info('Arrow key navigation test completed');\n      }\n    } else {\n      logger.warn('No navigation menu found on page');\n    }\n  });\n\n  /**\n   * Focus Visibility\n   * Ensures focused elements are visually distinguishable\n   */\n  test('Focused elements are visually visible', async ({ page }) => {\n    logger.info('Testing focus visibility');\n    \n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Press Tab to focus first element\n    await page.keyboard.press('Tab');\n    \n    const focusedElement = await page.evaluate(() => {\n      const el = document.activeElement as HTMLElement;\n      if (!el || el === document.body) return null;\n      \n      const styles = window.getComputedStyle(el);\n      const focusStyle = window.getComputedStyle(el, ':focus');\n      \n      return {\n        tagName: el.tagName,\n        hasOutline: styles.outline !== 'none' && styles.outline !== '',\n        hasBorder: styles.border !== 'none' && styles.border !== '',\n        backgroundColor: styles.backgroundColor\n      };\n    });\n    \n    if (focusedElement) {\n      logger.debug('Focused element styles', focusedElement);\n      \n      const hasVisibleFocus = focusedElement.hasOutline || focusedElement.hasBorder;\n      expect(hasVisibleFocus).toBe(true);\n      logger.info('Focus visibility test passed');\n    } else {\n      logger.warn('No focusable element found');\n    }\n  });\n\n  /**\n   * Focus Trap in Modals\n   * Ensures focus stays within modal when Tab is pressed\n   */\n  test('Focus is trapped within modals', async ({ page }) => {\n    logger.info('Testing focus trap in modals');\n    \n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Look for modal trigger\n    const modalTrigger = page.locator('button, [role=\"button\"]').filter({\n      hasText: /dialog|modal|popup|open/i\n    }).first();\n    \n    if (await modalTrigger.isVisible({ timeout: 2000 }).catch(() => false)) {\n      await modalTrigger.click();\n      await page.waitForTimeout(300);\n      \n      // Check if modal appeared\n      const modal = page.locator('[role=\"dialog\"], [aria-modal=\"true\"]').first();\n      \n      if (await modal.isVisible({ timeout: 1000 }).catch(() => false)) {\n        logger.debug('Modal is open, testing focus trap');\n        \n        // Get initial focused element\n        const initialFocused = await page.evaluate(() => {\n          return (document.activeElement as HTMLElement)?.getAttribute('class');\n        });\n        \n        // Tab through multiple times\n        for (let i = 0; i < 10; i++) {\n          await page.keyboard.press('Tab');\n        }\n        \n        // Check if focus is still within modal\n        const stillInModal = await page.evaluate(() => {\n          const modal = document.querySelector('[role=\"dialog\"], [aria-modal=\"true\"]');\n          const focused = document.activeElement;\n          return modal && modal.contains(focused);\n        });\n        \n        logger.debug('Focus still in modal after 10 tabs', { inModal: stillInModal });\n        logger.info('Focus trap test completed');\n      }\n    }\n  });\n\n  /**\n   * Skip Link Functionality\n   * Ensures skip to main content link works via keyboard\n   */\n  test('Skip links work for keyboard navigation', async ({ page }) => {\n    logger.info('Testing skip link functionality');\n    \n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Look for skip link (usually first focusable element)\n    const skipLink = page.locator('a[href=\"#main\"], a[href=\"#content\"], [data-testid=\"skip-link\"]').first();\n    \n    if (await skipLink.isVisible({ timeout: 1000 }).catch(() => false)) {\n      logger.info('Skip link found');\n      \n      // Tab to it (should be first)\n      await page.keyboard.press('Tab');\n      \n      const isFocused = await skipLink.evaluate((el) => {\n        return el === document.activeElement;\n      });\n      \n      if (isFocused) {\n        logger.debug('Skip link is focused');\n        \n        // Press Enter to activate\n        await page.keyboard.press('Enter');\n        await page.waitForTimeout(500);\n        \n        // Check if main content is focused\n        const mainContent = page.locator('main, [role=\"main\"], #content').first();\n        const isMainVisible = await mainContent.isVisible({ timeout: 1000 }).catch(() => false);\n        \n        logger.info('Skip link test completed', { mainVisible: isMainVisible });\n      } else {\n        logger.warn('Skip link is not first focusable element');\n      }\n    } else {\n      logger.warn('No skip link found - consider adding one');\n    }\n  });\n});\n"